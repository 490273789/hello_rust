pub fn ownership_mod() {
  println!("----- 所有权 ownership -----");
  // 解决的问题
  // 所有的程序都必须和计算机内存打交道，如何从内存中申请空间来存放程序的运行内容，如何在不需要的时候释放这些空间

  // 一些内存安全的常见问题
  // 悬空指针 Dangling Pointer
  // 二次释放 double free


  // rust的核心特性就是所有权
  // 所有的程序在运行时都必须管理他们使用计算机内存的方式
  //  - 有些语言有垃圾回收机制，在程序运行时，他们会不断地寻找不再使用的内存
  //  - 在其他语言中，程序员必须显示地分配和释放内存
  // rust采用了第三种方式
  //  - 内存是通过一个所有权系统来管理的，其中包含一组编译器在编译时检查的规则
  //  - 当程序运行时，所有权特性不会减慢程序的 运行速度。

  // stack vs heap
  // 在像rust这样的系统级编程语言里面，一个值是在stack上还是在heap上对语言的行为和你为什么做某些决定是有更大的影响的
  // 在代码运行的时候，stack和heap都是可用的内存，但是它们的结构很不相同。
  // stack： 按照值得接收顺序来存储，按照相反的顺序将它们移除； 后进先出 LIFO
  // 栈和堆的核心目标就是为程序在运行时提供可供使用的内存空间。

  // 重点
  // - 所有存储在stack上的数据必须拥有已知的固定的大小
  // - 编译时大小未知的数据或运行时大小可能发生变化的数据必须存放在heap上

  // heap 的内存组织性差一些
  // 当把 数据放入heap时，你会请求一定数量的空间
  // 操作系统在heap里找到一块足够大的空间，把他标记为在用，并返回一个指针，这个指针就是这个空间的地址
  // 因为指针是已知固定大小，可以把指针放到stack上
  // 对于大小未知或者可能变化的数据，我们需要将它存储在堆上。

  // 把数据压到stack上比分配到heap中要快的多
  // - 因为操作系统不需要去寻找存放数据的存储空间，那个位置永远都在stack的顶端

  // 在heap中存放数据需要更多的工作
  // - 首先要寻找足够大的空间来存放数据，然后做好记录方便下次分配
  // 访问heap中数据要比访问stack中的数据慢，因为需要指针才能找到heap中的数据

  // 对于现代的处理器来说，由于缓存的缘故，如果指令在内存中跳转的次数越少，则速度的越快

  // 当你的代码调用一个函数时，传递给函数的参数（包括可能指向堆上数据的指针和函数的局部变量）依次被压入栈中，当函数调用结束时，这些值将被从栈中按照相反的顺序依次移除。

  // 所有权存在的原因
  // 所有权解决的问题：
  // 1、跟踪代码的哪些部分正在使用heap的哪些数据
  // 2、最小化heap上的重复数据
  // 3、清理heap上未使用的数据以避免空间不足
  // 一旦你懂的了所有权，那么就不需要经常去想stack 或 heap了
  // 但是知道管理heap数据是所有权的原因，这有助于驾驶他为什么会这样工作

  // 所有权规则
  // 1、每一个值都被一个变量所拥有，该变量被称为值的所有者
  // 2、每一个值同时只能有一个所有者
  // 3、当所有者超出作用域（scope）时，该值将被删除
  let x = 5;
  let y = x;
  println!("x = {}, y = {}", x, y);
  // 这段代码没有发生所有权转移，栈上存的只是通过自动拷贝的方式赋值的
  // Rust 基本类型都是通过自动拷贝的方式来赋值的

  let s1 = String::from("hello");
  let s2 = s1;
  // 如果没有所有权，当是s1和 s2都离开作用域的时候会造成二次释放
  // rust的解决方案是：当s1被赋予s2后，rust认为s1不在有效，因此无需在s1离开作用域后drop任何东西，乍样就把所有权从s1转移给了s2。
  // 这个将所有权转移的操作成为 move（移动）他会将s1的堆地址、长度和容量移动到s2

  // 深拷贝
  // rust不会自动进行深拷贝
  // 如果我们需要复制比如String中堆上的数据可以使用clone方法

  // 浅拷贝 copy
  // 浅拷贝只会发生在栈上，性能比较高
  // 任何基本类型的组合可以 Copy ，不需要分配内存或某种形式资源的类型是可以 Copy 的

  // 将值传递给函数，一样会发生 移动 或者 复制

  let s3 = s2.clone();
  println!("s2 = {} s3 = {}", s2, s3);

  takes_ownership(s3); // 将s3的所有权移动到了函数中
  makes_copy(y); // 将 y copy到函数中，当前y还可以继续使用

  // 函数的返回值也有所有权
  let s4 = gives_ownership();

  // 经过函数将s4的所有权给到s5
  let s5 = takes_and_gives_back(s4);
  println!("s5 = {}", s5);

  println!("----- end -----");
  println!();
}


fn takes_ownership(some_string: String) {
  println!("{}", some_string);
} // 在这个位置some_string移出了作用域并调用drop方法

fn makes_copy(some_integer: i32) {
  println!("{}", some_integer);
} // 这里，some_integer 移出作用域。不会有特殊操作

fn gives_ownership() -> String {
  let some_string = String::from("hello");
  some_string
}

fn takes_and_gives_back(a_string: String) -> String {
  a_string
}